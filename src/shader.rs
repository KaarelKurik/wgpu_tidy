// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.15.2
// Changes made to this file will not be saved.
// SourceHash: c5111add2698aef6d97af2a0e6b05e8024a7847e8adeb79049339e5fc751b19b

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    Gorilla,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self {
            Self::Gorilla => gorilla::create_pipeline_layout(device),
        }
    }
    pub fn create_shader_module_embed_source(
        &self,
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        match self {
            Self::Gorilla => gorilla::create_shader_module_embed_source(device),
        }
    }
}
mod _root {
    pub use super::*;
}
pub mod layout_asserts {
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {
        assert!(std::mem::size_of:: < glam::Vec3A > () == 16);
        assert!(std::mem::align_of:: < glam::Vec3A > () == 16);
        assert!(std::mem::size_of:: < glam::Vec4 > () == 16);
        assert!(std::mem::align_of:: < glam::Vec4 > () == 16);
        assert!(std::mem::size_of:: < glam::Mat3A > () == 48);
        assert!(std::mem::align_of:: < glam::Mat3A > () == 16);
        assert!(std::mem::size_of:: < glam::Mat4 > () == 64);
        assert!(std::mem::align_of:: < glam::Mat4 > () == 16);
    };
    const GORILLA_SURFACE_PARAMS_STD140_0_ASSERTS: () = {
        assert!(std::mem::offset_of!(gorilla::SurfaceParams_std140_0, support_0) == 0);
        assert!(
            std::mem::offset_of!(gorilla::SurfaceParams_std140_0, point_count_0) == 4
        );
        assert!(std::mem::size_of:: < gorilla::SurfaceParams_std140_0 > () == 16);
    };
    const GORILLA_HERMITE_STD430_0_ASSERTS: () = {
        assert!(std::mem::offset_of!(gorilla::Hermite_std430_0, pos_0) == 0);
        assert!(std::mem::offset_of!(gorilla::Hermite_std430_0, normal_0) == 16);
        assert!(std::mem::size_of:: < gorilla::Hermite_std430_0 > () == 32);
    };
    const GORILLA__MATRIX_STORAGE_FLOAT3X3__COL_MAJORSTD140_0_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(gorilla::_MatrixStorage_float3x3_ColMajorstd140_0,
            data_0) == 0
        );
        assert!(
            std::mem::size_of:: < gorilla::_MatrixStorage_float3x3_ColMajorstd140_0 > ()
            == 48
        );
    };
    const GORILLA_CAMERA_STD140_0_ASSERTS: () = {
        assert!(std::mem::offset_of!(gorilla::Camera_std140_0, width_0) == 0);
        assert!(std::mem::offset_of!(gorilla::Camera_std140_0, height_0) == 4);
        assert!(std::mem::offset_of!(gorilla::Camera_std140_0, frame_0) == 16);
        assert!(std::mem::offset_of!(gorilla::Camera_std140_0, frame_inv_0) == 64);
        assert!(std::mem::offset_of!(gorilla::Camera_std140_0, centre_0) == 112);
        assert!(std::mem::offset_of!(gorilla::Camera_std140_0, yfov_0) == 124);
        assert!(std::mem::size_of:: < gorilla::Camera_std140_0 > () == 128);
    };
}
pub mod gorilla {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SurfaceParams_std140_0 {
        /// size: 4, offset: 0x0, type: `f32`
        pub support_0: f32,
        /// size: 4, offset: 0x4, type: `i32`
        pub point_count_0: i32,
        pub _pad_point_count_0: [u8; 0xC - core::mem::size_of::<i32>()],
    }
    impl SurfaceParams_std140_0 {
        pub const fn new(support_0: f32, point_count_0: i32) -> Self {
            Self {
                support_0,
                point_count_0,
                _pad_point_count_0: [0; 0xC - core::mem::size_of::<i32>()],
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SurfaceParams_std140_0Init {
        pub support_0: f32,
        pub point_count_0: i32,
    }
    impl SurfaceParams_std140_0Init {
        pub const fn build(&self) -> SurfaceParams_std140_0 {
            SurfaceParams_std140_0 {
                support_0: self.support_0,
                point_count_0: self.point_count_0,
                _pad_point_count_0: [0; 0xC - core::mem::size_of::<i32>()],
            }
        }
    }
    impl From<SurfaceParams_std140_0Init> for SurfaceParams_std140_0 {
        fn from(data: SurfaceParams_std140_0Init) -> Self {
            data.build()
        }
    }
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Hermite_std430_0 {
        /// size: 12, offset: 0x0, type: `vec3<f32>`
        pub pos_0: glam::Vec3A,
        /// size: 12, offset: 0x10, type: `vec3<f32>`
        pub normal_0: glam::Vec3A,
    }
    impl Hermite_std430_0 {
        pub const fn new(pos_0: glam::Vec3A, normal_0: glam::Vec3A) -> Self {
            Self { pos_0, normal_0 }
        }
    }
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct _MatrixStorage_float3x3_ColMajorstd140_0 {
        /// size: 48, offset: 0x0, type: `array<vec4<f32>, 3>`
        pub data_0: [glam::Vec4; 3],
        pub _pad_data_0: [u8; 0x30 - core::mem::size_of::<[glam::Vec4; 3]>()],
    }
    impl _MatrixStorage_float3x3_ColMajorstd140_0 {
        pub const fn new(data_0: [glam::Vec4; 3]) -> Self {
            Self {
                data_0,
                _pad_data_0: [0; 0x30 - core::mem::size_of::<[glam::Vec4; 3]>()],
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct _MatrixStorage_float3x3_ColMajorstd140_0Init {
        pub data_0: [glam::Vec4; 3],
    }
    impl _MatrixStorage_float3x3_ColMajorstd140_0Init {
        pub const fn build(&self) -> _MatrixStorage_float3x3_ColMajorstd140_0 {
            _MatrixStorage_float3x3_ColMajorstd140_0 {
                data_0: self.data_0,
                _pad_data_0: [0; 0x30 - core::mem::size_of::<[glam::Vec4; 3]>()],
            }
        }
    }
    impl From<_MatrixStorage_float3x3_ColMajorstd140_0Init>
    for _MatrixStorage_float3x3_ColMajorstd140_0 {
        fn from(data: _MatrixStorage_float3x3_ColMajorstd140_0Init) -> Self {
            data.build()
        }
    }
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Camera_std140_0 {
        /// size: 4, offset: 0x0, type: `f32`
        pub width_0: f32,
        /// size: 4, offset: 0x4, type: `f32`
        pub height_0: f32,
        pub _pad_height_0: [u8; 0xC - core::mem::size_of::<f32>()],
        /// size: 48, offset: 0x10, type: `struct`
        pub frame_0: _MatrixStorage_float3x3_ColMajorstd140_0,
        /// size: 48, offset: 0x40, type: `struct`
        pub frame_inv_0: _MatrixStorage_float3x3_ColMajorstd140_0,
        /// size: 12, offset: 0x70, type: `vec3<f32>`
        pub centre_0: glam::Vec3A,
        pub _pad_centre_0: [u8; 0xC - core::mem::size_of::<glam::Vec3A>()],
        /// size: 4, offset: 0x7C, type: `f32`
        pub yfov_0: f32,
    }
    impl Camera_std140_0 {
        pub const fn new(
            width_0: f32,
            height_0: f32,
            frame_0: _MatrixStorage_float3x3_ColMajorstd140_0,
            frame_inv_0: _MatrixStorage_float3x3_ColMajorstd140_0,
            centre_0: glam::Vec3A,
            yfov_0: f32,
        ) -> Self {
            Self {
                width_0,
                height_0,
                _pad_height_0: [0; 0xC - core::mem::size_of::<f32>()],
                frame_0,
                frame_inv_0,
                centre_0,
                _pad_centre_0: [0; 0xC - core::mem::size_of::<glam::Vec3A>()],
                yfov_0,
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Camera_std140_0Init {
        pub width_0: f32,
        pub height_0: f32,
        pub frame_0: _MatrixStorage_float3x3_ColMajorstd140_0,
        pub frame_inv_0: _MatrixStorage_float3x3_ColMajorstd140_0,
        pub centre_0: glam::Vec3A,
        pub yfov_0: f32,
    }
    impl Camera_std140_0Init {
        pub const fn build(&self) -> Camera_std140_0 {
            Camera_std140_0 {
                width_0: self.width_0,
                height_0: self.height_0,
                _pad_height_0: [0; 0xC - core::mem::size_of::<f32>()],
                frame_0: self.frame_0,
                frame_inv_0: self.frame_inv_0,
                centre_0: self.centre_0,
                _pad_centre_0: [0; 0xC - core::mem::size_of::<glam::Vec3A>()],
                yfov_0: self.yfov_0,
            }
        }
    }
    impl From<Camera_std140_0Init> for Camera_std140_0 {
        fn from(data: Camera_std140_0Init) -> Self {
            data.build()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub surface_0: wgpu::BufferBinding<'a>,
        pub surface_point_data_0: wgpu::BufferBinding<'a>,
        pub camera_0: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub surface_0: wgpu::BindGroupEntry<'a>,
        pub surface_point_data_0: wgpu::BindGroupEntry<'a>,
        pub camera_0: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                surface_0: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.surface_0),
                },
                surface_point_data_0: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.surface_point_data_0),
                },
                camera_0: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.camera_0),
                },
            }
        }
        pub fn as_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.surface_0, self.surface_point_data_0, self.camera_0]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.as_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
            label: Some("Gorilla::BindGroup0::LayoutDescriptor"),
            entries: &[
                /// @binding(1): "surface_0"
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: std::num::NonZeroU64::new(
                            std::mem::size_of::<_root::gorilla::SurfaceParams_std140_0>()
                                as _,
                        ),
                    },
                    count: None,
                },
                /// @binding(2): "surface_point_data_0"
                wgpu::BindGroupLayoutEntry {
                    binding: 2,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage {
                            read_only: true,
                        },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                /// @binding(0): "camera_0"
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: std::num::NonZeroU64::new(
                            std::mem::size_of::<_root::gorilla::Camera_std140_0>() as _,
                        ),
                    },
                    count: None,
                },
            ],
        };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(
            device: &wgpu::Device,
            bindings: WgpuBindGroup0Entries,
        ) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(&device);
            let entries = bindings.as_array();
            let bind_group = device
                .create_bind_group(
                    &wgpu::BindGroupDescriptor {
                        label: Some("Gorilla::BindGroup0"),
                        layout: &bind_group_layout,
                        entries: &entries,
                    },
                );
            Self(bind_group)
        }
        pub fn set<'a>(&self, render_pass: &mut wgpu::RenderPass<'a>) {
            render_pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut wgpu::RenderPass<'a>) {
            self.bind_group0.set(pass);
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::RenderPass<'a>,
        bind_group0: &'a WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub const ENTRY_VERTEX: &str = "vertex";
    pub const ENTRY_FRAGMENT: &str = "fragment";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize> {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: std::collections::HashMap<String, f64>,
    }
    pub fn vertex_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a VertexEntry<N>,
    ) -> wgpu::VertexState<'a> {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            },
        }
    }
    pub fn vertex_entry() -> VertexEntry<0> {
        VertexEntry {
            entry_point: ENTRY_VERTEX,
            buffers: [],
            constants: Default::default(),
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize> {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: std::collections::HashMap<String, f64>,
    }
    pub fn fragment_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a FragmentEntry<N>,
    ) -> wgpu::FragmentState<'a> {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            },
        }
    }
    pub fn fragment_entry(
        targets: [Option<wgpu::ColorTargetState>; 1],
    ) -> FragmentEntry<1> {
        FragmentEntry {
            entry_point: ENTRY_FRAGMENT,
            targets,
            constants: Default::default(),
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("Gorilla::PipelineLayout"),
                    bind_group_layouts: &[
                        &WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn create_shader_module_embed_source(
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("gorilla.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
    pub const SHADER_STRING: &'static str = r#"
struct SurfaceParams_std140_0_ {
    support_0_: f32,
    point_count_0_: i32,
}

struct Hermite_std430_0_ {
    pos_0_: vec3<f32>,
    normal_0_: vec3<f32>,
}

struct _MatrixStorage_float3x3_ColMajorstd140_0_ {
    data_0_: array<vec4<f32>, 3>,
}

struct Camera_std140_0_ {
    width_0_: f32,
    height_0_: f32,
    frame_0_: _MatrixStorage_float3x3_ColMajorstd140_0_,
    frame_inv_0_: _MatrixStorage_float3x3_ColMajorstd140_0_,
    centre_0_: vec3<f32>,
    yfov_0_: f32,
}

struct vertexOutput_0_ {
    @builtin(position) output_0_: vec4<f32>,
}

struct Hermite_0_ {
    pos_0_: vec3<f32>,
    normal_0_: vec3<f32>,
}

struct Camera_0_ {
    width_0_: f32,
    height_0_: f32,
    frame_0_: mat3x3<f32>,
    frame_inv_0_: mat3x3<f32>,
    centre_0_: vec3<f32>,
    yfov_0_: f32,
}

struct pixelOutput_0_ {
    @location(0) output_1_: vec4<f32>,
}

@group(0) @binding(1) 
var<uniform> surface_0_: SurfaceParams_std140_0_;
@group(0) @binding(2) 
var<storage> surface_point_data_0_: array<Hermite_std430_0_>;
@group(0) @binding(0) 
var<uniform> camera_0_: Camera_std140_0_;

fn unpackStorage_0_(_S1_: _MatrixStorage_float3x3_ColMajorstd140_0_) -> mat3x3<f32> {
    return mat3x3<f32>(vec3<f32>(_S1_.data_0_[0].x, _S1_.data_0_[1].x, _S1_.data_0_[2].x), vec3<f32>(_S1_.data_0_[0].y, _S1_.data_0_[1].y, _S1_.data_0_[2].y), vec3<f32>(_S1_.data_0_[0].z, _S1_.data_0_[1].z, _S1_.data_0_[2].z));
}

fn unpackStorage_1_(_S3_: Hermite_std430_0_) -> Hermite_0_ {
    var _S4_: Hermite_0_;

    _S4_ = Hermite_0_(_S3_.pos_0_, _S3_.normal_0_);
    let _e5 = _S4_;
    return _e5;
}

fn unpackStorage_2_(_S5_: Camera_std140_0_) -> Camera_0_ {
    var _S6_: Camera_0_;

    let _e4 = unpackStorage_0_(_S5_.frame_0_);
    let _e6 = unpackStorage_0_(_S5_.frame_inv_0_);
    _S6_ = Camera_0_(_S5_.width_0_, _S5_.height_0_, _e4, _e6, _S5_.centre_0_, _S5_.yfov_0_);
    let _e11 = _S6_;
    return _e11;
}

fn direct_render_hermite_0_(_S7_: Hermite_0_, _S8_: vec2<f32>) -> vec4<f32> {
    var _S9_: Camera_0_;
    var _S10_: vec3<f32>;
    var _S11_: vec3<f32>;
    var _S12_: f32;
    var _S13_: bool;
    var _S14_: vec2<f32>;
    var _S15_: vec2<f32>;
    var _S16_: f32;
    var _S17_: vec2<f32>;
    var _S18_: vec2<f32>;
    var _S19_: f32;
    var _S20_: vec2<f32>;

    let _e1 = camera_0_;
    let _e2 = unpackStorage_2_(_e1);
    _S9_ = _e2;
    let _e7 = _S9_.frame_inv_0_;
    _S10_ = (_S7_.pos_0_ * _e7);
    let _e14 = _S9_.frame_inv_0_;
    _S11_ = ((_S7_.pos_0_ + _S7_.normal_0_) * _e14);
    let _e18 = _S10_.z;
    _S12_ = _e18;
    let _e20 = _S12_;
    if (_e20 <= 0f) {
        _S13_ = true;
    } else {
        let _e26 = _S11_.z;
        _S13_ = (_e26 <= 0f);
    }
    let _e29 = _S13_;
    if _e29 {
        return vec4(0f);
    }
    let _e32 = _S10_;
    let _e34 = _S12_;
    _S14_ = (_e32.xy / vec2(_e34));
    let _e38 = _S11_;
    let _e41 = _S11_.z;
    _S15_ = (_e38.xy / vec2(_e41));
    let _e47 = camera_0_.yfov_0_;
    let _e55 = camera_0_.height_0_;
    _S16_ = ((2f * tan((_e47 / 2f))) / _e55);
    let _e62 = camera_0_.width_0_;
    let _e69 = camera_0_.height_0_;
    let _e74 = _S16_;
    _S17_ = (vec2<f32>((_S8_.x - (_e62 / 2f)), (_S8_.y - (_e69 / 2f))) * vec2(_e74));
    let _e78 = _S15_;
    let _e79 = _S14_;
    _S18_ = (_e78 - _e79);
    let _e82 = _S18_;
    let _e83 = _S15_;
    let _e84 = _S17_;
    let _e87 = _S18_;
    let _e88 = _S18_;
    _S19_ = (dot(_e82, (_e83 - _e84)) / dot(_e87, _e88));
    let _e92 = _S19_;
    if (_e92 < 0f) {
        _S13_ = true;
    } else {
        let _e96 = _S19_;
        _S13_ = (_e96 > 1f);
    }
    let _e99 = _S13_;
    if _e99 {
        return vec4(0f);
    }
    let _e102 = _S15_;
    let _e103 = _S14_;
    let _e104 = _S19_;
    let _e107 = _S17_;
    _S20_ = abs((mix(_e102, _e103, vec2(_e104)) - _e107));
    let _e112 = _S20_.x;
    let _e114 = _S20_.y;
    let _e116 = _S16_;
    if (max(_e112, _e114) > (_e116 / 2f)) {
        return vec4(0f);
    }
    let _e122 = _S19_;
    let _e124 = _S19_;
    return vec4<f32>(_e122, (1f - _e124), 0f, 1f);
}

@vertex 
fn vertex(@builtin(vertex_index) ix_0_: u32) -> vertexOutput_0_ {
    var vertices_0_: array<vec4<f32>, 3> = array<vec4<f32>, 3>(vec4<f32>(-1f, -1f, 0f, 1f), vec4<f32>(3f, -1f, 0f, 1f), vec4<f32>(-1f, 3f, 0f, 1f));
    var _S2_: vertexOutput_0_;

    let _e11 = vertices_0_[ix_0_];
    _S2_ = vertexOutput_0_(_e11);
    let _e14 = _S2_;
    return _e14;
}

@fragment 
fn fragment(@builtin(position) in_0_: vec4<f32>) -> pixelOutput_0_ {
    var _S21_: vec2<f32>;
    var i_0_: i32 = 0i;
    var _S23_: pixelOutput_0_ = pixelOutput_0_(vec4<f32>(0f, 0f, 0f, 1f));
    var _S24_: vec4<f32>;
    var _S25_: pixelOutput_0_;

    _S21_ = in_0_.xy;
    loop {
        {
            let _e9 = i_0_;
            let _e12 = surface_0_.point_count_0_;
            if (_e9 < _e12) {
            } else {
                break;
            }
            let _e15 = i_0_;
            let _e17 = surface_point_data_0_[_e15];
            let _e18 = unpackStorage_1_(_e17);
            let _e19 = _S21_;
            let _e20 = direct_render_hermite_0_(_e18, _e19);
            _S24_ = _e20;
            let _e23 = _S24_.w;
            if (_e23 > 0.5f) {
                let _e26 = _S24_;
                _S25_ = pixelOutput_0_(_e26);
                let _e29 = _S25_;
                return _e29;
            }
            let _e30 = i_0_;
            i_0_ = (_e30 + 1i);
        }
    }
    let _e34 = _S23_;
    return _e34;
}
"#;
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for gorilla::SurfaceParams_std140_0 {}
    unsafe impl bytemuck::Pod for gorilla::SurfaceParams_std140_0 {}
    unsafe impl bytemuck::Zeroable for gorilla::Hermite_std430_0 {}
    unsafe impl bytemuck::Pod for gorilla::Hermite_std430_0 {}
    unsafe impl bytemuck::Zeroable
    for gorilla::_MatrixStorage_float3x3_ColMajorstd140_0 {}
    unsafe impl bytemuck::Pod for gorilla::_MatrixStorage_float3x3_ColMajorstd140_0 {}
    unsafe impl bytemuck::Zeroable for gorilla::Camera_std140_0 {}
    unsafe impl bytemuck::Pod for gorilla::Camera_std140_0 {}
}
